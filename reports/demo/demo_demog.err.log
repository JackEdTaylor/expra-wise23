Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/jupyter_core/utils/__init__.py", line 173, in wrapped
    return loop.run_until_complete(inner)
  File "/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/asyncio/base_events.py", line 647, in run_until_complete
    return future.result()
  File "/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/opt/hostedtoolcache/Python/3.9.18/x64/lib/python3.9/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
demog <- read_csv("demog.csv")
------------------


Error: 'demog.csv' does not exist in current working directory ('/home/runner/work/expra-wise23/expra-wise23/lecture/demo').
Traceback:

1. read_csv("demog.csv")
2. vroom::vroom(file, delim = ",", col_names = col_names, col_types = col_types, 
 .     col_select = {
 .         {
 .             col_select
 .         }
 .     }, id = id, .name_repair = name_repair, skip = skip, n_max = n_max, 
 .     na = na, quote = quote, comment = comment, skip_empty_rows = skip_empty_rows, 
 .     trim_ws = trim_ws, escape_double = TRUE, escape_backslash = FALSE, 
 .     locale = locale, guess_max = guess_max, show_col_types = show_col_types, 
 .     progress = progress, altrep = lazy, num_threads = num_threads)
3. vroom_(file, delim = delim %||% col_types$delim, col_names = col_names, 
 .     col_types = col_types, id = id, skip = skip, col_select = col_select, 
 .     name_repair = .name_repair, na = na, quote = quote, trim_ws = trim_ws, 
 .     escape_double = escape_double, escape_backslash = escape_backslash, 
 .     comment = comment, skip_empty_rows = skip_empty_rows, locale = locale, 
 .     guess_max = guess_max, n_max = n_max, altrep = vroom_altrep(altrep), 
 .     num_threads = num_threads, progress = progress)
4. (function (path, write = FALSE) 
 . {
 .     if (is.raw(path)) {
 .         return(rawConnection(path, "rb"))
 .     }
 .     if (!is.character(path)) {
 .         return(path)
 .     }
 .     if (is_url(path)) {
 .         if (requireNamespace("curl", quietly = TRUE)) {
 .             con <- curl::curl(path)
 .         }
 .         else {
 .             inform("`curl` package not installed, falling back to using `url()`")
 .             con <- url(path)
 .         }
 .         ext <- tolower(tools::file_ext(path))
 .         return(switch(ext, zip = , bz2 = , xz = {
 .             close(con)
 .             stop("Reading from remote `", ext, "` compressed files is not supported,\n", 
 .                 "  download the files locally first.", call. = FALSE)
 .         }, gz = gzcon(con), con))
 .     }
 .     path <- enc2utf8(path)
 .     p <- split_path_ext(basename_utf8(path))
 .     if (write) {
 .         path <- normalizePath_utf8(path, mustWork = FALSE)
 .     }
 .     else {
 .         path <- check_path(path)
 .     }
 .     if (is_installed("archive")) {
 .         formats <- archive_formats(p$extension)
 .         extension <- p$extension
 .         while (is.null(formats) && nzchar(extension)) {
 .             extension <- split_path_ext(extension)$extension
 .             formats <- archive_formats(extension)
 .         }
 .         if (!is.null(formats)) {
 .             p$extension <- extension
 .             if (write) {
 .                 if (is.null(formats[[1]])) {
 .                   return(archive::file_write(path, filter = formats[[2]]))
 .                 }
 .                 return(archive::archive_write(path, p$path, format = formats[[1]], 
 .                   filter = formats[[2]]))
 .             }
 .             if (is.null(formats[[1]])) {
 .                 return(archive::file_read(path, filter = formats[[2]]))
 .             }
 .             return(archive::archive_read(path, format = formats[[1]], 
 .                 filter = formats[[2]]))
 .         }
 .     }
 .     if (!write) {
 .         compression <- detect_compression(path)
 .     }
 .     else {
 .         compression <- NA
 .     }
 .     if (is.na(compression)) {
 .         compression <- tools::file_ext(path)
 .     }
 .     if (write && compression == "zip") {
 .         stop("Can only read from, not write to, .zip", call. = FALSE)
 .     }
 .     switch(compression, gz = gzfile(path, ""), bz2 = bzfile(path, 
 .         ""), xz = xzfile(path, ""), zip = zipfile(path, ""), 
 .         if (!has_trailing_newline(path)) {
 .             file(path)
 .         } else {
 .             path
 .         })
 . })("demog.csv")
5. check_path(path)
6. stop("'", path, "' does not exist", if (!is_absolute_path(path)) {
 .     paste0(" in current working directory ('", getwd(), "')")
 . }, ".", call. = FALSE)

